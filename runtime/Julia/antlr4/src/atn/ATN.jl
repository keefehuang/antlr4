# Copyright (c) 2012-2017 The ANTLR Project. All rights reserved.
# Use of this file is governed by the BSD 3-clause license that
# can be found in the LICENSE.txt file in the project root.
#/
# from antlr4.IntervalSet import IntervalSet

# from antlr4.RuleContext import RuleContext

# from antlr4.Token import Token
# from antlr4.atn.ATNType import ATNType
# from antlr4.atn.ATNState import ATNState, DecisionState

using SuperEnum

global debug = false
global dfa_debug = false

@se ATNENUM begin
    INVALID_ALT_NUMBER=0
end



# Used for runtime deserialization of ATNs from strings#/
mutable struct ATN <: AbstractATN
    # The type of the ATN.
    grammarType::ATNType.ATNTypeEnum
    # The maximum value for any symbol recognized by a transition in the ATN.
    maxTokenType::Int
    states::Vector
    # Each subrule/rule is a decision poInt and we must track them so we
    #  can go back later and build DFA predictors for them.  This includes
    #  all the rules, subrules, optional blocks, ()+, ()* etc...
    decisionToState::Vector
    # Maps from rule index to starting state number.
    ruleToStartState::Union{Vector{RuleStartState},Nothing}
    # Maps from rule index to stop state number.
    ruleToStopState::Union{Vector{RuleStopState},Nothing}
    modeNameToStartState::Dict
    # For lexer ATNs, this maps the rule index to the resulting token type.
    # For parser ATNs, this maps the rule index to the generated bypass token
    # type if the
    # {@link ATNDeserializationOptions#isGenerateRuleBypassTransitions}
    # deserialization option was specified; otherwise, this is {@code null}.
    ruleToTokenType::Union{Vector{Int},Nothing}
    # For lexer ATNs, this is an array of {@link LexerAction} objects which may
    # be referenced by action transitions in the ATN.
    lexerActions::Vector{LexerAction}
    modeToStartState::Vector

    function ATN(grammarType::ATNType.ATNTypeEnum, maxTokenType::Int)
        new(grammarType, maxTokenType, [], [], nothing, nothing, Dict(), nothing, LexerAction[], [])
    end
end

# Compute the set of valid tokens that can occur starting in state {@code s}.
#  If {@code ctx} is null, the set of tokens will not include what can follow
#  the rule surrounding {@code s}. In other words, the set will be
#  restricted to tokens reachable staying within {@code s}'s rule.
function nextTokensInContext(atn::ATN, s::ATNState, ctx::RuleContext)
    analyzer = LL1Analyzer(atn)
    return Look(analyzer, s, ctx=ctx)
end

# Compute the set of valid tokens that can occur starting in {@code s} and
# staying in same rule. {@link Token#EPSILON} is in set if we reach end of
# rule.
function nextTokensNoContext!(atn::ATN, s::ATNState)
    if !isnothing(s.nextTokenWithinRule)
        return s.nextTokenWithinRule
    end
    s.nextTokenWithinRule = nextTokensInContext(atn, s, nothing)
    s.nextTokenWithinRule.readOnly = true
    return s.nextTokenWithinRule
end

function nextTokens(atn::ATN, s::ATNState, ctx::nRuleContext = nothing)
    if isnothing(ctx)
        return nextTokensNoContext!(atn, s)
    else
        return nextTokensInContext(atn, s, ctx)
    end
end

function addState!(atn::ATN, state::ATNState)
    if !isnothing(state)
        state.atn = atn
        state.stateNumber = length(atn.states)
    end
    push!(atn.states, state)
end

function removeState!(atn::ATN, state::ATNState)
    atn.states[state.stateNumber] = nothing # just free mem, don't shift states in list
end

function defineDecisionState(atn::ATN, s::DecisionState)
    push!(atn.decisionToState, s)
    s.decision = length(atn.decisionToState)
    return s.decision
end

function getDecisionState(atn::ATN, decision::Int)
    if length(atn.decisionToState) == 0
        return nothing
    else
        return atn.decisionToState[decision]
    end
end

# Computes the set of input symbols which could follow ATN state number
# {@code stateNumber} in the specified full {@code context}. This method
# considers the complete parser context, but does not evaluate semantic
# predicates (i.e. all predicates encountered during the calculation are
# assumed true). If a path in the ATN exists from the starting state to the
# {@link RuleStopState} of the outermost context without matching any
# symbols, {@link Token#EOF} is added to the returned set.
#
# <p>If {@code context} is {@code null}, it is treated as
# {@link ParserRuleContext#EMPTY}.</p>
#
# @param stateNumber the ATN state number
# @param context the full parse context
# @return The set of potentially valid input symbols which could follow the
# specified state in the specified context.
# @throws IllegalArgumentException if the ATN does not contain a state with
# number {@code stateNumber}
#/
function getExpectedTokens(atn::ATN, stateNumber::Int, ctx::RuleContext)
    if stateNumber < 0 || stateNumber >= length(atn.states)
        error("Invalid state number.")
    end
    s = atn.states[stateNumber]
    following = nextTokens(atn, s)
    if !(Token.EPSILON in following)
        return following
    end
    expected = IntervalSet()
    addset!(expected, following)
    removeOne!(expected, Token.EPSILON)
    while !isnothing(ctx) && ctx.invokingState >= 0 && Token.EPSILON in following
        invokingState = atn.states[ctx.invokingState]
        rt = invokingState.transitions[0]
        following = nextTokens(atn, rt.followState)
        addSet!(expected, following)
        removeOne!(expected, Token.EPSILON)
        ctx = ctx.parentCtx
    end
    if Token.EPSILON in following
        addOne!(expected, Token.EOF)
    end
    return expected
end

function readATN(atnd::ATNDeserializer)
    idx = readInt!(atnd)
    grammarType = ATNType.ATNTypeEnum(idx)
    maxTokenType = readInt!(atnd)
    return ATN(grammarType, maxTokenType)
end

function Base.string(atn::ATN)
    buf = IOBuffer()
    write(buf, "[")
    write(buf, string(atn.grammarType))
    write(buf, ", ")
    write(buf, string(atn.maxTokenType))
    write(buf, "]")
    String(take!(buf))
end

function Base.show(io::IO, ::MIME"text/plain", atn::ATN)
    println(io, string(atn))
end